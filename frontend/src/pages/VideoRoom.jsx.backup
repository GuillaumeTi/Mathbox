import { useState, useEffect, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { LiveKitRoom, VideoTrack, AudioTrack, useRoomContext, useTracks } from '@livekit/components-react';
import { Track, RoomEvent } from 'livekit-client';
import { useMultiCamera } from '../hooks/useMultiCamera';
import { useDrawing } from '../hooks/useDrawing';
import CameraSetup from '../components/CameraSetup';
import DrawingToolbar from '../components/DrawingToolbar';
import './VideoRoom.css';

function VideoRoom({ user, token }) {
    const { roomName } = useParams();
    const [livekitToken, setLivekitToken] = useState('');
    const [livekitUrl, setLivekitUrl] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(true);
    const navigate = useNavigate();

    useEffect(() => {
        fetchLivekitToken();
    }, [roomName]);

    const fetchLivekitToken = async () => {
        try {
            const response = await fetch('/api/livekit-token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`,
                },
                body: JSON.stringify({ room_name: roomName }),
            });

            if (!response.ok) {
                setError('Erreur de connexion √† la salle');
                setLoading(false);
                return;
            }

            const data = await response.json();
            setLivekitToken(data.token);
            setLivekitUrl(data.url);
            setLoading(false);
        } catch (error) {
            console.error('Error fetching LiveKit token:', error);
            setError('Erreur de connexion √† la salle');
            setLoading(false);
        }
    };

    if (error) {
        return (
            <div className="video-room-error">
                <div className="error-content">
                    <div className="error-icon">‚ö†Ô∏è</div>
                    <div className="error-message">{error}</div>
                    <button
                        onClick={() => navigate(user.role === 'PROF' ? '/professor' : '/student')}
                        className="btn-back"
                    >
                        Retour au tableau de bord
                    </button>
                </div>
            </div>
        );
    }

    if (loading) {
        return (
            <div className="video-room-loading">
                <div className="loading-content">
                    <div className="loading-spinner"></div>
                    <div className="loading-text">Connexion √† la salle...</div>
                </div>
            </div>
        );
    }

    return (
        <div className="video-room-container">
            <LiveKitRoom
                token={livekitToken}
                serverUrl={livekitUrl}
                connect={true}
                audio={true}
                video={user.role === 'PROF'} // Professor publishes video by default
                onError={(error) => console.error('LiveKit error:', error)}
            >
                <RoomContent
                    user={user}
                    onLeave={() => navigate(user.role === 'PROF' ? '/professor' : '/student')}
                />
            </LiveKitRoom>
        </div>
    );
}

function RoomContent({ user, onLeave }) {
    const room = useRoomContext();
    const isProfessor = user.role === 'PROF';
    const isStudent = user.role === 'STUDENT';

    // Multi-camera setup for students
    const cameraSetup = useMultiCamera(room, isStudent);

    // Drawing state
    const [tool, setTool] = useState('pen');
    const [color, setColor] = useState('#EF4444');
    const [isScreenSharing, setIsScreenSharing] = useState(false);

    // Get all tracks
    const tracks = useTracks([
        { source: Track.Source.Camera, withPlaceholder: false },
        { source: Track.Source.ScreenShare, withPlaceholder: false },
    ]);

    console.log('üìπ All tracks:', tracks.length, tracks.map(t => ({
        sid: t.publication?.trackSid,
        source: t.source,
        isLocal: t.participant.isLocal,
        identity: t.participant.identity
    })));

    // Separate local and remote tracks
    const localTracks = tracks.filter(t => t.participant.isLocal);
    const remoteTracks = tracks.filter(t => !t.participant.isLocal);

    // Find screen share
    const screenShareTrack = tracks.find(t => t.source === Track.Source.ScreenShare);

    // For professor: get student tracks (first = face, second = paper OR single = both)
    let studentFaceTrack = null;
    let studentPaperTrack = null;

    if (isProfessor) {
        const studentCameraTracks = remoteTracks.filter(t => t.source === Track.Source.Camera);
        console.log('üë®‚Äçüè´ Professor view - Student camera tracks:', studentCameraTracks.length);

        if (studentCameraTracks.length === 1) {
            // DEMO MODE: Single camera = both face and paper
            studentFaceTrack = studentCameraTracks[0];
            studentPaperTrack = studentCameraTracks[0];
            console.log('‚úÖ DEMO MODE: Single student camera used for both views', {
                sid: studentCameraTracks[0].publication?.trackSid,
                hasTrack: !!studentCameraTracks[0].publication?.track
            });
        } else if (studentCameraTracks.length >= 2) {
            // Dual camera: first = face, second = paper
            studentFaceTrack = studentCameraTracks[0];
            studentPaperTrack = studentCameraTracks[1];
            console.log('‚úÖ DUAL MODE: Using 2 student cameras', {
                face: studentCameraTracks[0].publication?.trackSid,
                paper: studentCameraTracks[1].publication?.trackSid
            });
        } else {
            console.log('‚ö†Ô∏è No student cameras detected yet');
        }
    }

    // For student: get own tracks
    let myFaceTrack = null;
    let myPaperTrack = null;

    if (isStudent) {
        const myCameraTracks = localTracks.filter(t => t.source === Track.Source.Camera);
        console.log('üë®‚Äçüéì Student view - My camera tracks:', myCameraTracks.length);

        if (myCameraTracks.length === 1) {
            myPaperTrack = myCameraTracks[0]; // Single camera shows as paper
            console.log('‚úÖ Single camera mode - showing as paper');
        } else if (myCameraTracks.length >= 2) {
            myFaceTrack = myCameraTracks[0];
            myPaperTrack = myCameraTracks[1];
            console.log('‚úÖ Dual camera mode', {
                face: myCameraTracks[0].publication?.trackSid,
                paper: myCameraTracks[1].publication?.trackSid
            });
        } else {
            console.log('‚ö†Ô∏è No cameras published yet');
        }
    }

    // Professor's camera
    const professorTrack = isProfessor ?
        localTracks.find(t => t.source === Track.Source.Camera) :
        remoteTracks.find(t => t.source === Track.Source.Camera);

    console.log('üë®‚Äçüè´ Professor track:', professorTrack ? 'YES' : 'NO');

    // Main video: screen share > paper camera
    const mainTrack = screenShareTrack || (isProfessor ? studentPaperTrack : myPaperTrack);
    const mainTrackSid = mainTrack?.publication?.trackSid;

    console.log('üé• Main track:', {
        exists: !!mainTrack,
        sid: mainTrackSid,
        source: mainTrack?.source,
        isScreenShare: !!screenShareTrack
    });

    // Handle screen sharing
    const handleScreenShare = async () => {
        if (isScreenSharing) {
            const screenTracks = room.localParticipant.videoTracks;
            screenTracks.forEach((publication) => {
                if (publication.source === Track.Source.ScreenShare) {
                    room.localParticipant.unpublishTrack(publication.track);
                }
            });
            setIsScreenSharing(false);
        } else {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: false
                });

                const track = stream.getVideoTracks()[0];

                track.onended = () => {
                    setIsScreenSharing(false);
                };

                await room.localParticipant.publishTrack(track, {
                    source: Track.Source.ScreenShare
                });

                setIsScreenSharing(true);
            } catch (error) {
                console.error('Error sharing screen:', error);
            }
        }
    };

    // Publish cameras after setup
    useEffect(() => {
        console.log('üìπ Camera publish effect triggered', {
            isStudent,
            showCameraSetup: cameraSetup.showCameraSetup,
            hasRoom: !!room
        });

        if (isStudent && !cameraSetup.showCameraSetup && room) {
            console.log('‚úÖ Calling publishCameras...');
            cameraSetup.publishCameras();
        } else {
            console.log('‚ö†Ô∏è Not publishing:', {
                isStudent,
                showCameraSetup: cameraSetup.showCameraSetup,
                hasRoom: !!room
            });
        }
    }, [cameraSetup.showCameraSetup, room, isStudent, cameraSetup]);

    return (
        <>
            {/* Camera Setup Modal for Students */}
            {isStudent && cameraSetup.showCameraSetup && (
                <CameraSetup
                    cameras={cameraSetup.cameras}
                    selectedFaceCamera={cameraSetup.selectedFaceCamera}
                    setSelectedFaceCamera={cameraSetup.setSelectedFaceCamera}
                    selectedPaperCamera={cameraSetup.selectedPaperCamera}
                    setSelectedPaperCamera={cameraSetup.setSelectedPaperCamera}
                    singleCameraType={cameraSetup.singleCameraType}
                    setSingleCameraType={cameraSetup.setSingleCameraType}
                    onConfirm={async () => {
                        console.log('üé¨ onConfirm - calling publishCameras...');
                        await cameraSetup.publishCameras();
                        console.log('‚úÖ publishCameras done, closing modal');
                        cameraSetup.setShowCameraSetup(false);
                    }}
                />
            )}

            {/* Main Room Interface */}
            <div className="room-layout">
                {/* Main Video Area (80% - Paper or Screen Share) */}
                <div className="main-video-area">
                    {mainTrack ? (
                        <VideoWithCanvas
                            trackRef={mainTrack}
                            trackSid={mainTrackSid}
                            room={room}
                            isProfessor={isProfessor}
                            tool={tool}
                            color={color}
                        />
                    ) : (
                        <div className="no-video-placeholder">
                            <div className="placeholder-icon">üìπ</div>
                            <div className="placeholder-text">
                                {isProfessor ? "En attente de la cam√©ra de l'√©tudiant..." : "En attente..."}
                            </div>
                        </div>
                    )}
                </div>

                {/* PiP Videos */}
                {/* Top Right: Student Face (for professor) or Professor Face (for student) */}
                {((isProfessor && studentFaceTrack) || (isStudent && professorTrack)) && (
                    <div className="pip-top-right">
                        <VideoTrack
                            trackRef={isProfessor ? studentFaceTrack : professorTrack}
                            className="pip-video"
                        />
                        <AudioTrack trackRef={isProfessor ? studentFaceTrack : professorTrack} />
                        <div className="pip-label">
                            {isProfessor ? '√âtudiant' : 'Professeur'}
                        </div>
                    </div>
                )}

                {/* Bottom Right: Professor (for professor) or Student Face (for student) */}
                {((isProfessor && professorTrack) || (isStudent && myFaceTrack)) && (
                    <div className="pip-bottom-right">
                        <VideoTrack
                            trackRef={isProfessor ? professorTrack : myFaceTrack}
                            className="pip-video"
                        />
                        <AudioTrack trackRef={isProfessor ? professorTrack : myFaceTrack} />
                        <div className="pip-label">
                            Moi
                        </div>
                    </div>
                )}

                {/* Drawing Toolbar (Professor only) */}
                {isProfessor && mainTrack && (
                    <DrawingToolbar
                        tool={tool}
                        setTool={setTool}
                        color={color}
                        setColor={setColor}
                        onClearAll={() => {
                            // Clear will be handled by sending message to VideoWithCanvas
                            if (room && mainTrackSid) {
                                const clearData = {
                                    type: 'clear',
                                    trackSid: mainTrackSid
                                };
                                const encoder = new TextEncoder();
                                const payload = encoder.encode(JSON.stringify(clearData));
                                room.localParticipant.publishData(payload, { reliable: true });

                                // Also clear locally
                                const event = new CustomEvent('clearCanvas', { detail: { trackSid: mainTrackSid } });
                                window.dispatchEvent(event);
                            }
                        }}
                        onScreenShare={handleScreenShare}
                        isScreenSharing={isScreenSharing}
                    />
                )}

                {/* Leave Button */}
                <button onClick={onLeave} className="btn-leave">
                    üö™ Quitter
                </button>
            </div>
        </>
    );
}

// Component that combines video and canvas
function VideoWithCanvas({ trackRef, trackSid, room, isProfessor, tool, color }) {
    const canvasRef = useRef(null);
    const videoRef = useRef(null);
    const lineWidth = tool === 'highlighter' ? 20 : tool === 'pen' ? 3 : 5;

    // Drawing hook
    const drawing = useDrawing(canvasRef, trackSid, room, isProfessor);

    // Listen for drawing data from remote
    useEffect(() => {
        if (!room) return;

        const handleData = (payload) => {
            drawing.handleDataReceived(payload);
        };

        room.on(RoomEvent.DataReceived, handleData);

        return () => {
            room.off(RoomEvent.DataReceived, handleData);
        };
    }, [room, drawing]);

    // Listen for clear canvas event
    useEffect(() => {
        const handleClear = (e) => {
            if (e.detail.trackSid === trackSid && canvasRef.current) {
                const ctx = canvasRef.current.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                }
            }
        };

        window.addEventListener('clearCanvas', handleClear);
        return () => window.removeEventListener('clearCanvas', handleClear);
    }, [trackSid]);

    return (
        <div className="main-video-wrapper" ref={videoRef}>
            <VideoTrack
                trackRef={trackRef}
                className="main-video"
            />
            <AudioTrack trackRef={trackRef} />

            {/* Fixed size canvas overlay */}
            <canvas
                ref={canvasRef}
                className="drawing-canvas"
                width={1920}
                height={1080}
                onMouseDown={drawing.startDrawing}
                onMouseMove={(e) => drawing.draw(e, color, lineWidth)}
                onMouseUp={drawing.stopDrawing}
                onMouseLeave={drawing.stopDrawing}
                onTouchStart={drawing.startDrawing}
                onTouchMove={(e) => drawing.draw(e, color, lineWidth)}
                onTouchEnd={drawing.stopDrawing}
                style={{
                    cursor: isProfessor ? 'crosshair' : 'default',
                    pointerEvents: isProfessor ? 'auto' : 'none'
                }}
            />
        </div>
    );
}

export default VideoRoom;
